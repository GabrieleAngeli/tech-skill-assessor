<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tech Skill Assessor</title>
  <style>
    :root {
      --bg: #0b1020;
      --panel: rgba(255,255,255,0.04);
      --panel2: rgba(255,255,255,0.09);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.65);
      --border: rgba(255,255,255,0.14);
      --good: rgba(80,200,120,0.95);
      --bad: rgba(255,90,90,0.95);
      --warn: rgba(255,200,80,0.95);
      --shadow: 0 10px 40px rgba(0,0,0,0.35);
      --radius: 16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      font-family: var(--sans);
      background: radial-gradient(1200px 10000px at 30% 20%, #0b2a45 0%, var(--bg) 55%, #03060b 100%);
      color: var(--text);
    }
    header { padding: 26px 18px 12px; max-width: 1100px; margin: 0 auto; }
    .title { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
    h1 { margin: 0; letter-spacing: -0.02em; font-size: 22px; }
    .sub { margin-top: 6px; color: var(--muted); font-size: 13.5px; line-height: 1.35; }
    main { max-width: 1100px; margin: 0 auto; padding: 14px 18px 50px; display: grid; grid-template-columns: 1fr; gap: 14px; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); padding: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 7px 10px; border-radius: 999px; border: 1px solid var(--border); background: rgba(255,255,255,0.06); color: var(--muted); font-size: 12.5px; user-select: none; }
    .btn { border: 1px solid var(--border); background: rgba(255,255,255,0.07); color: var(--text); border-radius: 12px; padding: 9px 12px; font-size: 13px; cursor: pointer; transition: transform 0.05s ease, background 0.15s ease; }
    .btn:hover { background: rgba(255,255,255,0.11); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: rgba(96,165,250,0.22); border-color: rgba(96,165,250,0.35); }
    .btn:disabled { opacity: 0.55; cursor: not-allowed; }
    .grid { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 10px; }
    @media (max-width: 900px) { .grid { grid-template-columns: repeat(2, minmax(0, 1fr)); } }
    @media (max-width: 620px) { .grid { grid-template-columns: 1fr; } }
    .tech { display: flex; gap: 10px; align-items: flex-start; padding: 12px; border: 1px solid var(--border); border-radius: 14px; background: rgba(255,255,255,0.05); cursor: pointer; user-select: none; }
    .tech input { margin-top: 3px; }
    .tech .tname { font-weight: 650; }
    .tech .tdesc { margin-top: 3px; font-size: 12.5px; color: var(--muted); line-height: 1.25; }
    .control { display: grid; grid-template-columns: 170px 1fr; gap: 10px; align-items: center; padding: 10px 12px; border: 1px solid var(--border); border-radius: 14px; background: rgba(255,255,255,0.05); }
    .control label { font-size: 12.5px; color: var(--muted); }
    select { width: 100%; border: 1px solid var(--border); background: rgba(0,0,0,0.20); color: var(--text); border-radius: 12px; padding: 10px 12px; outline: none; }
    .hr { height: 1px; background: rgba(255,255,255,0.10); margin: 12px 0; }

    .quizHeader { display: flex; align-items: center; justify-content: space-between; gap: 12px; flex-wrap: wrap; }
    .qMeta { display: flex; gap: 8px; flex-wrap: wrap; }
    .qPrompt { font-size: 16px; line-height: 1.35; margin: 12px 0 10px; white-space: pre-wrap; }
    .qCode { font-family: var(--mono); font-size: 12.5px; border: 1px solid rgba(255,255,255,0.12); background: rgba(0,0,0,0.22); border-radius: 14px; padding: 12px; overflow: auto; max-height: 220px; white-space: pre; }
    .options { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
    .opt { border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.05); border-radius: 14px; padding: 10px 12px; display: flex; gap: 10px; align-items: flex-start; cursor: pointer; user-select: none; }
    .opt:hover { background: rgba(255,255,255,0.08); }
    .opt input { margin-top: 2px; }
    .opt .otext { font-size: 13.5px; line-height: 1.25; }
    .opt.correct { border-color: rgba(80,200,120,0.35); background: rgba(80,200,120,0.10); }
    .opt.wrong { border-color: rgba(255,90,90,0.32); background: rgba(255,90,90,0.08); }

    .editor { width: 100%; min-height: 210px; font-family: var(--mono); font-size: 12.5px; line-height: 1.4; padding: 12px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.22); color: var(--text); outline: none; resize: vertical; tab-size: 2; }
    .feedback { margin-top: 12px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.14); background: rgba(255,255,255,0.04); padding: 12px; }
    .feedback.good { border-color: rgba(80,200,120,0.35); background: rgba(80,200,120,0.10); }
    .feedback.bad { border-color: rgba(255,90,90,0.32); background: rgba(255,90,90,0.08); }
    .feedback .title { font-weight: 700; font-size: 13.5px; margin-bottom: 6px; }
    .feedback .body { color: var(--muted); font-size: 12.5px; line-height: 1.35; white-space: pre-wrap; }

    .lockNote { margin-top: 10px; padding: 10px 12px; border-radius: 14px; border: 1px dashed rgba(255,255,255,0.22); background: rgba(0,0,0,0.18); font-size: 12.5px; color: rgba(255,255,255,0.75); display: none; }
    .locked .opt { pointer-events: none; opacity: 0.95; }
    .locked textarea.editor { cursor: not-allowed; }
    .locked input, .locked textarea, .locked select { pointer-events: none; opacity: 0.85; }

    .muted { color: var(--muted); }
    .small { font-size: 12.5px; }

    .charts { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 900px) { .charts { grid-template-columns: 1fr; } }
    canvas { width: 100%; height: 320px; border-radius: 14px; border: 1px solid rgba(255,255,255,0.14); background: rgba(0,0,0,0.18); }

    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 10px 10px; border-bottom: 1px solid rgba(255,255,255,0.10); text-align: left; }
    th { color: rgba(255,255,255,0.78); font-weight: 650; }
    .kbd { font-family: var(--mono); font-size: 12px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); padding: 2px 6px; border-radius: 8px; }

    /* --- Quiz layout: left navigation + main question --- */
    .quizLayout { display: grid; grid-template-columns: 0.7fr 1.3fr; gap: 12px; align-items: start; }
    @media (max-width: 900px) { .quizLayout { grid-template-columns: 1fr; } }

    .navPanel {
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.16);
      border-radius: 14px;
      padding: 12px;
      position: sticky;
      top: 12px;
      max-height: calc(100vh - 220px);
      overflow: auto;
    }
    @media (max-width: 900px) { .navPanel { position: static; max-height: none; } }

    .qNavList { display: grid; grid-template-columns: 1fr; gap: 8px; }

    .qNavItem {
      width: 100%;
      text-align: left;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      border-radius: 14px;
      padding: 9px 10px;
      cursor: pointer;
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      transition: background 0.15s ease, transform 0.05s ease;
    }
    .qNavItem:hover { background: rgba(255,255,255,0.08); }
    .qNavItem:active { transform: translateY(1px); }
    .qNavItem.active { outline: 2px solid rgba(96,165,250,0.45); }
    .qNavLeft { display: flex; align-items: center; gap: 10px; min-width: 0; }
    .qNavNum { font-family: var(--mono); font-size: 12px; opacity: 0.9; width: 32px; }
    .qNavTitle { font-size: 12.5px; color: rgba(255,255,255,0.85); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .qNavMeta { font-size: 11.5px; color: var(--muted); white-space: nowrap; }
    .qDot { width: 9px; height: 9px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.22); background: rgba(255,255,255,0.10); flex: 0 0 auto; }
    .qDot.good { border-color: rgba(80,200,120,0.50); background: rgba(80,200,120,0.65); }
    .qDot.bad { border-color: rgba(255,90,90,0.45); background: rgba(255,90,90,0.65); }

    .timeNote { margin-top: 10px; padding: 10px 12px; border-radius: 14px; border: 1px dashed rgba(255,255,255,0.22); background: rgba(0,0,0,0.18); font-size: 12.5px; color: rgba(255,255,255,0.75); }

  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>Tech Skill Assessor</h1>
      <div class="row">
        <button class="btn" id="btnResetAll" title="Reset all progress">Reset</button>
        <button class="btn" id="btnExport" title="Copy a Markdown report">Copy Report</button>
      </div>
    </div>
    <div class="sub">
      Select technologies, generate an assessment, answer questions, then export a Markdown report (skills + evidence).
      <br/>Rule: once you click <span class="kbd">Check</span> on a question, your answer is locked and can't be changed (even if you go back).
    </div>
  </header>

  <main>
    <section class="card" id="setupCard">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight: 700; font-size: 14px;">Setup</div>
          <div class="muted small" style="margin-top:4px;">Choose what you want to assess.</div>
        </div>
        <div class="row">
          <button class="btn primary" id="btnGenerate">Generate Assessment</button>
        </div>
      </div>

      <div class="hr"></div>

      <div class="grid" id="techGrid"></div>

      <div class="hr"></div>

      <div class="row">
        <div class="control" style="flex:1; min-width: 320px;">
          <label for="mode">Levels</label>
          <select id="mode">
            <option value="mixed">Mixed (L1 + L2 + L3)</option>
            <option value="l1">Foundation (Level 1)</option>
            <option value="l2">Intermediate (Level 2)</option>
            <option value="l3">Advanced (Level 3)</option>
          </select>
        </div>
        <div class="control" style="flex:1; min-width: 320px;">
          <label for="length">Questions per tech</label>
          <select id="length">
            <option value="short">Short (4)</option>
            <option value="medium" selected>Medium (7)</option>
            <option value="long">Long (10)</option>
          </select>
        </div>
      </div>

      <div class="muted small" style="margin-top:10px;">
        Tip: include code questions for stronger evidence ‚Äî they are auto-tested and scored only if tests pass.
      </div>
    </section>

    <section class="card" id="quizCard" style="display:none;">
  <div class="quizLayout">
    <aside class="navPanel">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight: 700; font-size: 14px;">Questions</div>
          <div class="muted small" style="margin-top:4px;">Jump to any question (answers lock after <span class="kbd">Check</span>).</div>
        </div>
      </div>
      <div class="hr"></div>
      <div class="qNavList" id="qNav"></div>
      <div class="timeNote" id="timePolicyNote" style="margin-top:12px;">
        ‚è± Time policy: score starts decreasing after <span class="kbd" id="timeThresholdLabel">30s</span> on a question.
      </div>
    </aside>

    <div>
      <div class="quizHeader">
        <div class="qMeta" id="qMeta"></div>
        <div class="row">
          <button class="btn" id="btnPrev">Prev</button>
          <button class="btn" id="btnNext">Next</button>
          <button class="btn primary" id="btnCheck">Check</button>
        </div>
      </div>
      <div class="lockNote" id="lockNote">Locked: you already checked this question. You can review, but you can't change the answer.</div>
      <div class="qPrompt" id="qPrompt"></div>
      <pre class="qCode" id="qCode" style="display:none;"></pre>

      <div id="answerArea"></div>
      <div id="feedbackArea"></div>
    </div>
  </div>
</section>

    <section class="card" id="resultsCard" style="display:none;">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight: 700; font-size: 14px;">Results</div>
          <div class="muted small" style="margin-top:4px;">Scores are based on checked answers. Code questions must pass tests.</div>
        </div>
        <div class="row">
          <button class="btn primary" id="btnShowReport">Show Report</button>
        </div>
      </div>
      <div class="hr"></div>
      <div class="charts">
        <div>
          <div class="muted small" style="margin: 0 0 6px 2px;">Radar (normalized per tech)</div>
          <canvas id="radar"></canvas>
        </div>
        <div>
          <div class="muted small" style="margin: 0 0 6px 2px;">Bar (score per tech)</div>
          <canvas id="bar"></canvas>
        </div>
      </div>
      <div class="hr"></div>
      <div id="scoreTable"></div>
    </section>

    <section class="card" id="reportCard" style="display:none;">
      <div class="row" style="justify-content: space-between;">
        <div>
          <div style="font-weight: 700; font-size: 14px;">Markdown Report</div>
          <div class="muted small" style="margin-top:4px;">Copy, paste into README/Notion/Confluence, or attach to a self-review.</div>
        </div>
        <div class="row">
          <button class="btn" id="btnCopyMd">Copy Markdown</button>
          <button class="btn" id="btnDownloadMd">Download .md</button>
          <button class="btn" id="btnBackToResults">Back</button>
        </div>
      </div>
      <div class="hr"></div>
      <textarea class="editor" id="mdOut" spellcheck="false"></textarea>
      <div class="muted small" style="margin-top:8px;">
        Copy uses a safe fallback for <span class="kbd">file://</span> usage.
      </div>
    </section>
  </main>

<script>

  let QUESTION_BANK_BUILTIN = [];

  let TECHS = [];

  const STORAGE_KEY = "tech-skill-assessor.v2";

  

  const TIME_PENALTY_THRESHOLD_SEC = 30;   // after this time, score starts decreasing
  const TIME_PENALTY_MIN_MULT = 0.25;      // minimum multiplier for correct answers
async function loadJson(url) {
    const res = await fetch(url, { cache: "no-store" });
    if (!res.ok) throw new Error(`Failed to load ${url} (${res.status})`);
    return await res.json();
  }

  function getParam(name) {
    const u = new URL(location.href);
    return u.searchParams.get(name);
  }

  async function loadBankAndTechs() {
    // opzionale: permetti override via querystring
    const techsUrl = getParam("techs") || "https://raw.githubusercontent.com/GabrieleAngeli/tech-skill-assessor/refs/heads/main/techs.json";
    const bankUrl  = getParam("bank")  || "https://raw.githubusercontent.com/GabrieleAngeli/tech-skill-assessor/refs/heads/main/question-bank.json";

    const [techs, bank] = await Promise.all([
      loadJson(techsUrl),
      loadJson(bankUrl)
    ]);

    validateTechs(techs);
    validateBank(bank, techs);

    TECHS = techs;
    QUESTION_BANK_BUILTIN = bank;
  }

  function validateTechs(techs) {
    if (!Array.isArray(techs) || techs.length === 0) throw new Error("TECHS must be a non-empty array");
    for (const t of techs) {
      if (!t?.id || !t?.name) throw new Error("Each tech needs {id, name}");
    }
  }

  function validateBank(bank, techs) {
    if (!Array.isArray(bank) || bank.length === 0) throw new Error("Question bank must be a non-empty array");
    const techIds = new Set(techs.map(t => t.id));

    for (const q of bank) {
      if (!q?.id || !q?.tech || !q?.level || !q?.type || !q?.prompt) {
        throw new Error(`Invalid question shape (missing fields) for id=${q?.id ?? "(no id)"}`);
      }
      if (!techIds.has(q.tech)) throw new Error(`Question ${q.id} uses unknown tech '${q.tech}'`);
      if ((q.type === "mcq" || q.type === "multi") && (!Array.isArray(q.options) || !Array.isArray(q.answer))) {
        throw new Error(`Question ${q.id} must have options[] and answer[]`);
      }
    }
  }

  const state = {
    selectedTechs: new Set(),
    mode: "mixed",
    length: "medium",
    quiz: null, // { questions:[], idx:0, answers:{qid:{value, checked, correct, score, detail}} }
  };

  // ---------- persistence ----------
  function persistState() {
    try {
      const obj = {
        selectedTechs: Array.from(state.selectedTechs),
        mode: state.mode,
        length: state.length,
        quiz: state.quiz,
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
    } catch (e) {
      // ignore
    }
  }

  function restoreState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      state.selectedTechs = new Set(obj.selectedTechs || []);
      state.mode = obj.mode || "mixed";
      state.length = obj.length || "medium";
      state.quiz = obj.quiz || null;
    
      // sanitize timers: avoid counting time while the page was closed
      if (state.quiz && state.quiz.timers) {
        for (const k of Object.keys(state.quiz.timers)) {
          if (state.quiz.timers[k]) state.quiz.timers[k].startedAt = null;
        }
      }
} catch (e) {
      // ignore
    }
  }

  // ---------- utils ----------
  function byId(id) { return document.getElementById(id); }
  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function techName(techId) {
    return (TECHS.find(t => t.id === techId) || {name: techId}).name;
  }

  function countPerTech() {
    const len = state.length;
    if (len === "short") return 4;
    if (len === "long") return 10;
    return 7;
  }

  function levelsForMode() {
    if (state.mode === "l1") return [1];
    if (state.mode === "l2") return [2];
    if (state.mode === "l3") return [3];
    return [1,2,3];
  }

  function shuffle(arr) {
    const a = arr.slice();
    for (let i=a.length-1; i>0; i--) {
      const j = Math.floor(Math.random()*(i+1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  // --- option randomization helpers (stable per quiz/session) ---
  // order: newIndex -> oldIndex
  function shuffledOrder(n) {
    const order = Array.from({ length: n }, (_, i) => i);
    for (let i = order.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [order[i], order[j]] = [order[j], order[i]];
    }
    return order;
  }

  // inv: oldIndex -> newIndex
  function invertOrder(order) {
    const inv = [];
    order.forEach((oldIdx, newIdx) => { inv[oldIdx] = newIdx; });
    return inv;
  }

  function applyOrder(arr, order) {
    return order.map(oldIdx => arr[oldIdx]);
  }

  // compat: allow calling helpers via `this.*` in DOM event handlers (e.g., shuffledOrder)
  // without requiring code changes for older snippets.
  try {
    if (typeof HTMLElement !== "undefined") {
      if (!HTMLElement.prototype.shuffledOrder) Object.defineProperty(HTMLElement.prototype, "shuffledOrder", { value: shuffledOrder });
      if (!HTMLElement.prototype.invertOrder) Object.defineProperty(HTMLElement.prototype, "invertOrder", { value: invertOrder });
      if (!HTMLElement.prototype.applyOrder) Object.defineProperty(HTMLElement.prototype, "applyOrder", { value: applyOrder });
    }
  } catch (e) {}

  function normalizeText(s) {
    return (s || "").trim().toLowerCase().replace(/\s+/g, " ");
  }


// ---------- timing + time-based scoring ----------
function ensureTimers() {
  if (!state.quiz) return null;
  if (!state.quiz.timers) state.quiz.timers = {};
  return state.quiz.timers;
}

function ensureTimer(qid) {
  ensureTimers();
  if (!state.quiz.timers[qid]) {
    state.quiz.timers[qid] = { totalMs: 0, startedAt: null, checkedMs: null };
  }
  return state.quiz.timers[qid];
}

function stopTiming(qid) {
  if (!state.quiz) return;
  const t = ensureTimer(qid);
  if (t.startedAt != null && t.checkedMs == null) {
    t.totalMs += (Date.now() - t.startedAt);
    t.startedAt = null;
  }
}

function resumeTiming(qid) {
  if (!state.quiz) return;
  const a = state.quiz.answers?.[qid];
  const t = ensureTimer(qid);
  if (a?.checked || t.checkedMs != null) { t.startedAt = null; return; }
  if (t.startedAt == null) t.startedAt = Date.now();
}

function switchActiveQuestion(qid) {
  if (!state.quiz) return;
  const prev = state.quiz.activeQid;
  if (prev && prev !== qid) stopTiming(prev);
  resumeTiming(qid);
  state.quiz.activeQid = qid;
}

function elapsedMsFor(qid) {
  if (!state.quiz) return 0;
  const t = ensureTimer(qid);
  let ms = t.totalMs || 0;
  if (t.startedAt != null && t.checkedMs == null) ms += (Date.now() - t.startedAt);
  if (t.checkedMs != null) ms = t.checkedMs;
  return Math.max(0, ms);
}

function fmtSec(sec) {
  if (!isFinite(sec)) return "-";
  if (sec < 60) return sec.toFixed(1) + "s";
  const m = Math.floor(sec / 60);
  const s = Math.round(sec % 60);
  return m + "m " + s + "s";
}

function timePenaltyMultiplier(elapsedSec) {
  if (!isFinite(elapsedSec) || elapsedSec <= TIME_PENALTY_THRESHOLD_SEC) return 1;
  const mult = TIME_PENALTY_THRESHOLD_SEC / elapsedSec;
  return clamp(mult, TIME_PENALTY_MIN_MULT, 1);
}

let _ticker = null;
function startTicker() {
  if (_ticker) return;
  _ticker = setInterval(() => {
    if (!state.quiz) return;
    const quizCard = byId("quizCard");
    if (!quizCard || quizCard.style.display === "none") return;
    updateTimeUI();
  }, 250);
}
function stopTicker() {
  if (_ticker) { clearInterval(_ticker); _ticker = null; }
}

function updateTimeUI() {
  if (!state.quiz) return;
  const qid = state.quiz.questions[state.quiz.idx];
  const pill = byId("qTimePill");
  if (pill) {
    const sec = elapsedMsFor(qid) / 1000;
    pill.textContent = "Time: " + fmtSec(sec);
  }
  const nodes = document.querySelectorAll("[data-qnav-time='1']");
  for (const n of nodes) {
    const id = n.getAttribute("data-qid");
    if (!id) continue;
    const sec = elapsedMsFor(id) / 1000;
    n.textContent = fmtSec(sec);
  }
}

function renderQuestionNav(activeQid) {
  const nav = byId("qNav");
  if (!nav || !state.quiz) return;
  nav.innerHTML = "";

  const qids = state.quiz.questions;
  qids.forEach((qid, idx) => {
    const q = QUESTION_BANK_BUILTIN.find(x => x.id === qid);
    const a = state.quiz.answers?.[qid];

    const btn = document.createElement("button");
    btn.className = "qNavItem" + (qid === activeQid ? " active" : "");
    btn.type = "button";

    const dot = document.createElement("span");
    dot.className = "qDot" + (a?.checked ? (a.correct ? " good" : " bad") : "");

    const left = document.createElement("div");
    left.className = "qNavLeft";

    const num = document.createElement("span");
    num.className = "qNavNum";
    num.textContent = String(idx + 1).padStart(2, "0");

    const titleWrap = document.createElement("div");
    titleWrap.style.minWidth = "0";

    const t1 = document.createElement("div");
    t1.className = "qNavTitle";
    t1.textContent = `${techName(q.tech)} ¬∑ L${q.level} ¬∑ ${q.type.toUpperCase()}`;

    const t2 = document.createElement("div");
    t2.className = "qNavMeta";
    t2.textContent = a?.checked ? (a.correct ? "Checked ¬∑ Correct" : "Checked ¬∑ Not correct") : "Not checked";

    titleWrap.appendChild(t1);
    titleWrap.appendChild(t2);

    left.appendChild(dot);
    left.appendChild(num);
    left.appendChild(titleWrap);

    const right = document.createElement("span");
    right.className = "qNavMeta";
    right.setAttribute("data-qnav-time", "1");
    right.setAttribute("data-qid", qid);
    right.textContent = fmtSec(elapsedMsFor(qid) / 1000);

    btn.appendChild(left);
    btn.appendChild(right);

    btn.addEventListener("click", () => {
      const cur = state.quiz.questions[state.quiz.idx];
      stopTiming(cur);
      state.quiz.idx = idx;
      persistState();
      renderQuiz();
    });

    nav.appendChild(btn);
  });
}

  function isLocked(qid) {
    const a = state.quiz?.answers?.[qid];
    return !!a?.checked; // checked => locked
  }

  // ---------- rendering setup ----------
  function renderTechGrid() {
    const grid = byId("techGrid");
    grid.innerHTML = "";
    for (const t of TECHS) {
      const el = document.createElement("div");
      el.className = "tech";
      el.innerHTML = `
        <input type="checkbox" ${state.selectedTechs.has(t.id) ? "checked" : ""} />
        <div>
          <div class="tname">${t.name}</div>
          <div class="tdesc">${t.description || ""}</div>
        </div>
      `;
      el.addEventListener("click", () => {
        const input = el.querySelector("input");
        const checked = !input.checked;
        input.checked = checked;
        if (checked) state.selectedTechs.add(t.id);
        else state.selectedTechs.delete(t.id);
        persistState();
      });
      grid.appendChild(el);
    }
  }

  // ---------- question picking ----------
  function pickQuestions() {
    const techs = Array.from(state.selectedTechs);
    const perTech = countPerTech();
    const levels = levelsForMode();

    const questions = [];
    for (const tech of techs) {
      const pool = QUESTION_BANK_BUILTIN.filter(q => q.tech === tech && levels.includes(q.level));
      const buckets = new Map();
      for (const lvl of levels) {
        buckets.set(lvl, shuffle(pool.filter(q => q.level === lvl)));
      }

      const picked = [];
      if (levels.length === 1) {
        picked.push(...buckets.get(levels[0]).slice(0, perTech));
      } else {
        let i = 0;
        while (picked.length < perTech) {
          const lvl = levels[i % levels.length];
          const b = buckets.get(lvl);
          const next = b.shift();
          if (next) picked.push(next);
          else {
            const anyLeft = levels.some(l => buckets.get(l).length > 0);
            if (!anyLeft) break;
          }
          i++;
        }
      }
      questions.push(...picked);
    }
    return shuffle(questions);
  }

  // ---------- code runner (web worker with timeout) ----------
  function makeWorker() {
    const workerCode = `
      function deepEqual(a,b) {
        if (a === b) return true;
        if (Number.isNaN(a) && Number.isNaN(b)) return true;
        if (typeof a !== typeof b) return false;
        if (a && b && typeof a === 'object') {
          if (Array.isArray(a) !== Array.isArray(b)) return false;
          const ak = Object.keys(a).sort();
          const bk = Object.keys(b).sort();
          if (ak.length !== bk.length) return false;
          for (let i=0;i<ak.length;i++) if (ak[i] !== bk[i]) return false;
          for (const k of ak) if (!deepEqual(a[k], b[k])) return false;
          return true;
        }
        return false;
      }

      function stableHashFNV1a(str) {
        let h = 0x811c9dc5;
        for (let i=0; i<str.length; i++) {
          h ^= str.charCodeAt(i);
          h = (h * 0x01000193) >>> 0;
        }
        return h >>> 0;
      }

      function predicate(name, actual, context) {
        if (name === 'nonneg32') {
          return Number.isInteger(actual) && actual >= 0 && actual <= 0xFFFFFFFF;
        }
        if (name === 'stableSameInput') {
          const s = context?.input || '';
          const expected = stableHashFNV1a(s);
          return Number.isInteger(actual) && actual === expected;
        }
        return false;
      }

      self.onmessage = async (ev) => {
        const msg = ev.data;
        try {
          const src = String(msg.code || "");
          const fnName = String(msg.functionName || "");
          const tests = msg.tests || [];
          const moduleFunc = new Function('"use strict";\\n' + src + '\\n; return (typeof ' + fnName + ' === "function") ? ' + fnName + ' : null;');
          const fn = moduleFunc();
          if (!fn) {
            self.postMessage({ ok:false, error: "Function '" + fnName + "' not found. Make sure it's declared with that exact name." });
            return;
          }

          const results = [];
          let passed = 0;

          for (const t of tests) {
            const args = Array.isArray(t.args) ? t.args : [];
            let actual;
            let ok = false;
            let err = null;
            try {
              actual = fn(...args);
              if (t.expected_predicate) {
                ok = predicate(t.expected_predicate, actual, { input: args[0] });
              } else if (t.expected !== undefined) {
                ok = deepEqual(actual, t.expected);
              } else if (t.expectedPartial) {
                ok = true;
                for (const k of Object.keys(t.expectedPartial)) {
                  if (!deepEqual(actual?.[k], t.expectedPartial[k])) ok = false;
                }
              } else {
                ok = true;
              }
            } catch (e) {
              err = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
              ok = false;
            }
            if (ok) passed++;
            results.push({ name: t.name || "test", ok, expected: t.expected, expected_predicate: t.expected_predicate, actual, error: err });
          }

          self.postMessage({ ok:true, passed, total: results.length, results });
        } catch (e) {
          const err = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
          self.postMessage({ ok:false, error: err });
        }
      };
    `;
    const blob = new Blob([workerCode], { type: "text/javascript" });
    const url = URL.createObjectURL(blob);
    const w = new Worker(url);
    return w;
  }

  async function runCodeTests(q, userCode) {
    const w = makeWorker();
    try {
      const timeoutMs = q.timeoutMs || 900;
      const p = new Promise((resolve) => { w.onmessage = (ev) => resolve(ev.data); });
      w.postMessage({ code: userCode, functionName: q.functionName, tests: q.tests });
      const timer = new Promise((resolve) => setTimeout(() => resolve({ ok:false, error: "Timeout: code took too long (" + timeoutMs + "ms)." }), timeoutMs));
      const res = await Promise.race([p, timer]);
      return res;
    } finally {
      w.terminate();
    }
  }

  // ---------- quiz rendering ----------
  function renderQuiz() {
    if (!state.quiz) return;

    const quizCard = byId("quizCard");
    const resultsCard = byId("resultsCard");
    const reportCard = byId("reportCard");

    quizCard.style.display = "";
    resultsCard.style.display = "none";
    reportCard.style.display = "none";

    const qid = state.quiz.questions[state.quiz.idx];
    const q = QUESTION_BANK_BUILTIN.find(x => x.id === qid);
    const ans = state.quiz.answers[qid] || { value: null, checked: false, correct: false, score: 0, detail: null };

    
    // timing + nav
    switchActiveQuestion(qid);
    renderQuestionNav(qid);
    try { const tl = byId("timeThresholdLabel"); if (tl) tl.textContent = TIME_PENALTY_THRESHOLD_SEC + "s"; } catch(e) {}
    startTicker();
// meta
    const qMeta = byId("qMeta");
    qMeta.innerHTML = "";
    const pills = [
  { label: `Tech: ${techName(q.tech)}` },
  { label: `Level: L${q.level}` },
  { label: `Type: ${q.type.toUpperCase()}` },
  { label: `Question: ${state.quiz.idx+1}/${state.quiz.questions.length}` },
];
for (const p of pills) {
  const el = document.createElement("span");
  el.className = "pill";
  el.textContent = p.label;
  qMeta.appendChild(el);
}

const timePill = document.createElement("span");
timePill.className = "pill";
timePill.id = "qTimePill";
timePill.textContent = "Time: " + fmtSec(elapsedMsFor(qid) / 1000);
qMeta.appendChild(timePill);

const pol = document.createElement("span");
pol.className = "pill";
pol.textContent = `Penalty after: ${TIME_PENALTY_THRESHOLD_SEC}s`;
qMeta.appendChild(pol);

    // prompt & optional code block
    byId("qPrompt").textContent = q.prompt;
    const qCode = byId("qCode");
    if (q.code) {
      qCode.style.display = "";
      qCode.textContent = q.code;
    } else {
      qCode.style.display = "none";
      qCode.textContent = "";
    }

    // lock UI
    const locked = isLocked(qid);
    quizCard.classList.toggle("locked", locked);
    byId("lockNote").style.display = locked ? "block" : "none";

    // nav
    byId("btnPrev").disabled = state.quiz.idx === 0;
    byId("btnNext").disabled = state.quiz.idx === state.quiz.questions.length - 1;
    byId("btnCheck").disabled = locked ? true : false;

    // answer area
    const area = byId("answerArea");
    area.innerHTML = "";

    if (q.type === "mcq" || q.type === "multi") {
      const opts = document.createElement("div");
      opts.className = "options";
      const type = (q.type === "mcq") ? "radio" : "checkbox";

      const variant = state.quiz?.variants?.[qid] || null;
      const displayOptions = variant ? applyOrder(q.options, variant.order) : q.options;
      const correctIdx = variant ? variant.answersShuffled : q.answer;

      const selected = new Set(Array.isArray(ans.value) ? ans.value : []);
      displayOptions.forEach((txt, i) => {
        const opt = document.createElement("div");
        opt.className = "opt";
        const input = document.createElement("input");
        input.type = type;
        input.name = "q_" + qid;
        input.checked = selected.has(i);
        input.disabled = locked;

        const label = document.createElement("div");
        label.className = "otext";
        label.textContent = txt;

        opt.appendChild(input);
        opt.appendChild(label);

        const onPick = () => {
          if (locked) return;
          if (type === "radio") {
            state.quiz.answers[qid] = { ...ans, value: [i] };
          } else {
            const next = new Set(selected);
            if (next.has(i)) next.delete(i);
            else next.add(i);
            state.quiz.answers[qid] = { ...ans, value: Array.from(next).sort((a,b)=>a-b) };
          }
          persistState();
          renderQuiz();
        };

        opt.addEventListener("click", (ev) => {
          if (locked) return;
          if (ev.target && ev.target.tagName === "INPUT") return;
          onPick();
        });
        input.addEventListener("change", () => onPick());

        if (ans.checked) {
          const isCorrectOption = correctIdx.includes(i);
          const isSelected = (ans.value || []).includes(i);
          if (isCorrectOption) opt.classList.add("correct");
          else if (isSelected && !isCorrectOption) opt.classList.add("wrong");
        }

        opts.appendChild(opt);
      });
      area.appendChild(opts);
    }

    if (q.type === "short") {
      const wrap = document.createElement("div");
      wrap.innerHTML = `
        <div class="muted small" style="margin: 8px 0 6px;">Answer (free text):</div>
        <input id="shortInput" style="width:100%;border:1px solid rgba(255,255,255,0.14);background:rgba(0,0,0,0.20);color:var(--text);border-radius:12px;padding:10px 12px;outline:none;" />
        <div class="muted small" style="margin-top:8px;">Accepted: ${(q.accepted||[]).map(a => '<span class="kbd">'+a+'</span>').join(" ")}</div>
      `;
      area.appendChild(wrap);
      const input = wrap.querySelector("#shortInput");
      input.value = ans.value || "";
      input.disabled = locked;
      input.addEventListener("input", () => {
        if (locked) return;
        state.quiz.answers[qid] = { ...ans, value: input.value };
        persistState();
      });
    }

    if (q.type === "code") {
      const wrap = document.createElement("div");
      wrap.innerHTML = `
        <div class="muted small" style="margin: 8px 0 6px;">Edit code. Your answer is correct only if all tests pass.</div>
        <textarea class="editor" id="codeInput" spellcheck="false"></textarea>
        <div class="muted small" style="margin-top:8px;">Function to implement: <span class="kbd">${q.functionName}</span> ‚Ä¢ Tests: <span class="kbd">${q.tests.length}</span></div>
      `;
      area.appendChild(wrap);
      const input = wrap.querySelector("#codeInput");
      input.value = ans.value || q.starter || "";
      input.disabled = locked;
      input.addEventListener("input", () => {
        if (locked) return;
        state.quiz.answers[qid] = { ...ans, value: input.value };
        persistState();
      });
    }

    renderFeedback(q, ans);
  }

  function renderFeedback(q, ans) {
    const fb = byId("feedbackArea");
    fb.innerHTML = "";
    if (!ans.checked) return;

    const div = document.createElement("div");
    div.className = "feedback " + (ans.correct ? "good" : "bad");

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = ans.correct ? "Correct" : "Not correct";

    const body = document.createElement("div");
    body.className = "body";

    const timeLine = (ans.timeSec != null) ? (`Time: ${fmtSec(ans.timeSec)} ‚Ä¢ Multiplier: x${(ans.timeMult ?? 1).toFixed(2)}`) : null;

    if (q.type === "code" && ans.detail) {
      if (ans.detail.ok) {
        const lines = [];
        if (timeLine) lines.push(timeLine);

        lines.push(`Tests passed: ${ans.detail.passed}/${ans.detail.total}`);
        for (const r of ans.detail.results) {
          lines.push(`- ${r.ok ? "‚úÖ" : "‚ùå"} ${r.name}${r.ok ? "" : " (expected: " + JSON.stringify(r.expected ?? r.expected_predicate) + ", actual: " + JSON.stringify(r.actual) + ")"}`);
          if (r.error) lines.push("  error: " + r.error);
        }
        lines.push("");
        lines.push("Explanation: " + (q.explain || ""));
        body.textContent = lines.join("\n");
      } else {
        body.textContent = (timeLine ? (timeLine + "\n\n") : "") + (ans.detail.error || "Code error") + "\n\nExplanation: " + (q.explain || "");
      }
    } else {
      body.textContent = (timeLine ? (timeLine + "\n\n") : "") + (q.explain || "");
    }

    div.appendChild(title);
    div.appendChild(body);
    fb.appendChild(div);
  }

  // ---------- checking ----------
  function scoreQuestion(q, value, detail) {
    // Score in [0..1]
    // For MCQ/MULTI we compare against the *shuffled* answer indices (stable per quiz).
    const variant = state.quiz?.variants?.[q.id] || null;
    const expected = (q.type === "mcq" || q.type === "multi")
      ? (variant ? variant.answersShuffled : q.answer)
      : null;

    if (q.type === "mcq") {
      const sel = Array.isArray(value) ? value : [];
      const correct = sel.length === 1 && expected.length === 1 && sel[0] === expected[0];
      return { correct, score: correct ? 1 : 0 };
    }
    if (q.type === "multi") {
      const sel = Array.isArray(value) ? value.slice().sort((a,b)=>a-b) : [];
      const ans = expected.slice().sort((a,b)=>a-b);
      const correct = sel.length === ans.length && sel.every((x,i)=>x===ans[i]);
      return { correct, score: correct ? 1 : 0 };
    }
    if (q.type === "short") {
      const v = normalizeText(String(value || ""));
      const accepted = (q.accepted || []).map(normalizeText);
      const correct = accepted.includes(v);
      return { correct, score: correct ? 1 : 0 };
    }
    if (q.type === "code") {
      const correct = !!detail?.ok && detail.passed === detail.total;
      return { correct, score: correct ? 1 : 0 };
    }
    return { correct: false, score: 0 };
  }

  async function checkCurrent() {
    const qid = state.quiz.questions[state.quiz.idx];
    const q = QUESTION_BANK_BUILTIN.find(x => x.id === qid);
    const ans = state.quiz.answers[qid] || { value: null, checked: false, correct: false, score: 0, detail: null };

    // Already checked => LOCKED (cannot modify, even if navigating back)
    if (ans.checked) { renderQuiz(); return; }

    let detail = null;
    if (q.type === "code") {
      const code = String(ans.value || q.starter || "");
      byId("btnCheck").disabled = true;
      const oldText = byId("btnCheck").textContent;
      byId("btnCheck").textContent = "Checking‚Ä¶";
      try {
        detail = await runCodeTests(q, code);
      } finally {
        byId("btnCheck").textContent = oldText;
      }
    }

    // stop timer and compute elapsed time for this question
stopTiming(qid);
const elapsedSec = elapsedMsFor(qid) / 1000;

const s = scoreQuestion(q, ans.value, detail);

// Apply time penalty only to correct answers
const mult = s.correct ? timePenaltyMultiplier(elapsedSec) : 1;
const finalScore = s.score * mult;

// freeze elapsed time
const t = ensureTimer(qid);
t.checkedMs = elapsedMsFor(qid);

state.quiz.answers[qid] = {
  value: ans.value,
  checked: true,   // ‚úÖ LOCK HERE
  correct: s.correct,
  rawScore: s.score,
  timeSec: elapsedSec,
  timeMult: mult,
  score: finalScore,
  detail,
  checkedAt: Date.now(),
};
    persistState();
    renderQuiz();

    if (isAllChecked()) renderResults();
  }

  function isAllChecked() {
    if (!state.quiz) return false;
    return state.quiz.questions.every(qid => !!state.quiz.answers[qid]?.checked);
  }

  // ---------- results ----------
  function computeScores() {
    const out = {};
    for (const qid of state.quiz.questions) {
      const q = QUESTION_BANK_BUILTIN.find(x => x.id === qid);
      const a = state.quiz.answers[qid];
      if (!a?.checked) continue;
      const key = q.tech;
      if (!out[key]) out[key] = { points: 0, max: 0, l1:{p:0,m:0}, l2:{p:0,m:0}, l3:{p:0,m:0} };
      out[key].points += a.score;
      out[key].max += 1;
      const bucket = "l" + q.level;
      out[key][bucket].p += a.score;
      out[key][bucket].m += 1;
    }

    const summary = [];
    for (const tech of Array.from(state.selectedTechs)) {
      const s = out[tech] || { points:0, max:0, l1:{p:0,m:0}, l2:{p:0,m:0}, l3:{p:0,m:0} };
      const pct = s.max ? (s.points / s.max) : 0;
      let label = "Needs review";
      if (pct >= 0.85) label = "Strong";
      else if (pct >= 0.65) label = "Solid";
      else if (pct >= 0.45) label = "Developing";

      summary.push({
        tech,
        name: techName(tech),
        points: s.points,
        max: s.max,
        pct,
        label,
        byLevel: {
          1: s.l1.m ? (s.l1.p / s.l1.m) : null,
          2: s.l2.m ? (s.l2.p / s.l2.m) : null,
          3: s.l3.m ? (s.l3.p / s.l3.m) : null,
        }
      });
    }
    summary.sort((a,b)=> b.pct - a.pct);
    return summary;
  }

  function renderScoreTable(summary) {
    const container = byId("scoreTable");
    const rows = summary.map(s => `
      <tr>
        <td><b>${s.name}</b><div class="muted small">${s.label}</div></td>
        <td>${Math.round(s.pct*100)}%</td>
        <td class="muted small">${s.max ? (s.points.toFixed(1) + " / " + s.max) : "-"}</td>
        <td class="muted small">
          L1: ${s.byLevel[1]===null ? "-" : Math.round(s.byLevel[1]*100)+"%"} ‚Ä¢
          L2: ${s.byLevel[2]===null ? "-" : Math.round(s.byLevel[2]*100)+"%"} ‚Ä¢
          L3: ${s.byLevel[3]===null ? "-" : Math.round(s.byLevel[3]*100)+"%"}
        </td>
      </tr>
    `).join("");

    container.innerHTML = `
      <table>
        <thead><tr><th>Technology</th><th>Score</th><th>Points</th><th>By level</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function clearCanvas(c) {
    const ctx = c.getContext("2d");
    const dpr = window.devicePixelRatio || 1;
    const w = c.clientWidth * dpr;
    const h = c.clientHeight * dpr;
    if (c.width !== w || c.height !== h) { c.width = w; c.height = h; }
    ctx.clearRect(0,0,c.width,c.height);
    return ctx;
  }

  function drawRadar(summary) {
    const c = byId("radar");
    const ctx = clearCanvas(c);
    const dpr = window.devicePixelRatio || 1;
    const W = c.width, H = c.height;
    const cx = W/2, cy = H/2;
    const r = Math.min(W,H)*0.32;

    ctx.save();
    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1*dpr;

    for (let k=1;k<=4;k++) {
      const rr = r*(k/4);
      ctx.beginPath();
      ctx.arc(cx, cy, rr, 0, Math.PI*2);
      ctx.stroke();
    }

    const labels = summary.map(s => s.name);
    const values = summary.map(s => s.pct);
    const n = labels.length;
    if (n === 0) return;

    for (let i=0;i<n;i++) {
      const ang = -Math.PI/2 + i*(Math.PI*2/n);
      const x = cx + r*Math.cos(ang);
      const y = cy + r*Math.sin(ang);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(x, y);
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,0.75)";
      ctx.font = `${12*dpr}px ${getComputedStyle(document.body).fontFamily}`;
      const lx = cx + (r*1.15)*Math.cos(ang);
      const ly = cy + (r*1.15)*Math.sin(ang);
      const text = labels[i];
      const tw = ctx.measureText(text).width;
      ctx.fillText(text, lx - tw/2, ly + 4*dpr);
    }

    ctx.beginPath();
    for (let i=0;i<n;i++) {
      const ang = -Math.PI/2 + i*(Math.PI*2/n);
      const rr = r*values[i];
      const x = cx + rr*Math.cos(ang);
      const y = cy + rr*Math.sin(ang);
      if (i===0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.fillStyle = "rgba(96,165,250,0.18)";
    ctx.strokeStyle = "rgba(96,165,250,0.55)";
    ctx.lineWidth = 2*dpr;
    ctx.fill();
    ctx.stroke();

    ctx.restore();
  }

  function drawBar(summary) {
    const c = byId("bar");
    const ctx = clearCanvas(c);
    const dpr = window.devicePixelRatio || 1;
    const W = c.width, H = c.height;

    const pad = 18*dpr;
    const x0 = pad*1.2;
    const y0 = H - pad*1.3;
    const x1 = W - pad*0.9;
    const y1 = pad*1.0;

    ctx.strokeStyle = "rgba(255,255,255,0.14)";
    ctx.lineWidth = 1*dpr;
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y0);
    ctx.stroke();

    const n = summary.length;
    if (n === 0) return;

    const barW = (x1 - x0) / n;
    for (let i=0;i<n;i++) {
      const s = summary[i];
      const h = (y0 - y1) * s.pct;
      const bx = x0 + i*barW + barW*0.18;
      const bw = barW*0.64;
      const by = y0 - h;

      ctx.fillStyle = "rgba(167,139,250,0.28)";
      ctx.fillRect(bx, by, bw, h);

      ctx.fillStyle = "rgba(255,255,255,0.80)";
      ctx.font = `${11*dpr}px ${getComputedStyle(document.body).fontFamily}`;
      const pct = Math.round(s.pct*100) + "%";
      const tw = ctx.measureText(pct).width;
      ctx.fillText(pct, bx + bw/2 - tw/2, by - 6*dpr);

      const name = s.name;
      ctx.fillStyle = "rgba(255,255,255,0.65)";
      ctx.font = `${10*dpr}px ${getComputedStyle(document.body).fontFamily}`;
      const ltw = ctx.measureText(name).width;
      ctx.fillText(name, bx + bw/2 - ltw/2, y0 + 14*dpr);
    }
  }

  function renderResults() {
    // stop timing current question when leaving quiz
    if (state.quiz?.activeQid) stopTiming(state.quiz.activeQid);
    stopTicker();
    byId("resultsCard").style.display = "";
    byId("quizCard").style.display = "none";
    byId("reportCard").style.display = "none";

    const summary = computeScores();
    renderScoreTable(summary);
    drawRadar(summary);
    drawBar(summary);
  }

  function buildMarkdown() {
    const now = new Date();
    const dt = now.toISOString().slice(0,10);

    const summary = computeScores();
    const lines = [];
    lines.push(`# Tech Skill Assessment`);
    lines.push(`- Date: **${dt}**`);
    lines.push(`- Mode: **${state.mode}**`);
    lines.push(`- Questions/tech: **${countPerTech()}**`);
    lines.push(`- Technologies: **${Array.from(state.selectedTechs).map(techName).join(", ")}**`);
    lines.push("");
    lines.push(`## Summary by technology`);
    for (const s of summary) {
      lines.push(`- **${s.name}** ‚Äî **${Math.round(s.pct*100)}%** (${s.label})`);
    }
    lines.push("");
    lines.push(`## Skill matrix`);
    lines.push(`| Technology | Score | L1 | L2 | L3 | Evidence |`);
    lines.push(`|---|---:|---:|---:|---:|---|`);
    for (const s of summary) {
      const l1 = s.byLevel[1]===null ? "-" : Math.round(s.byLevel[1]*100)+"%";
      const l2 = s.byLevel[2]===null ? "-" : Math.round(s.byLevel[2]*100)+"%";
      const l3 = s.byLevel[3]===null ? "-" : Math.round(s.byLevel[3]*100)+"%";
      const evidence = s.pct >= 0.85 ? "‚úÖ strong signal" : (s.pct >= 0.65 ? "üü° moderate" : "üîé needs more proof");
      lines.push(`| ${s.name} | ${Math.round(s.pct*100)}% | ${l1} | ${l2} | ${l3} | ${evidence} |`);
    }
    lines.push("");
    lines.push(`## Answer log (checked only)`);
    for (const qid of state.quiz.questions) {
      const q = QUESTION_BANK_BUILTIN.find(x => x.id === qid);
      const a = state.quiz.answers[qid];
      if (!a?.checked) continue;

      lines.push(`### ${techName(q.tech)} ¬∑ L${q.level} ¬∑ ${q.type.toUpperCase()}`);
      lines.push(q.prompt);
      lines.push("");
      if (q.type === "mcq" || q.type === "multi") {
        const selected = Array.isArray(a.value) ? a.value : [];
        const variant = state.quiz?.variants?.[qid] || null;
        const displayOptions = variant ? applyOrder(q.options, variant.order) : q.options;
        const selectedText = selected.map(i => displayOptions[i]).filter(Boolean);
        lines.push(`- Answer: ${selectedText.length ? selectedText.join(" | ") : "_(no answer)_"}`);
        lines.push(`- Result: ${a.correct ? "‚úÖ correct" : "‚ùå not correct"}`);
        lines.push(`- Time: ${a.timeSec!=null ? fmtSec(a.timeSec) : "-"} ‚Ä¢ Multiplier: x${(a.timeMult ?? 1).toFixed(2)} ‚Ä¢ Score: ${(a.score ?? 0).toFixed(2)}/1`);
} else if (q.type === "short") {
        lines.push(`- Answer: ${a.value ? "`"+String(a.value).replace(/`/g,"\\`")+"`" : "_(blank)_"}`);
        lines.push(`- Result: ${a.correct ? "‚úÖ correct" : "‚ùå not correct"}`);
        lines.push(`- Time: ${a.timeSec!=null ? fmtSec(a.timeSec) : "-"} ‚Ä¢ Multiplier: x${(a.timeMult ?? 1).toFixed(2)} ‚Ä¢ Score: ${(a.score ?? 0).toFixed(2)}/1`);
} else if (q.type === "code") {
        lines.push(`- Result: ${a.correct ? "‚úÖ tests passed" : "‚ùå tests failed"}`);
        lines.push(`- Time: ${a.timeSec!=null ? fmtSec(a.timeSec) : "-"} ‚Ä¢ Multiplier: x${(a.timeMult ?? 1).toFixed(2)} ‚Ä¢ Score: ${(a.score ?? 0).toFixed(2)}/1`);
        lines.push("");
        lines.push("```js");
        lines.push(String(a.value || q.starter || "").replace(/\r\n/g,"\n"));
        lines.push("```");
        if (a.detail?.ok) lines.push(`- Tests: ${a.detail.passed}/${a.detail.total}`);
        else lines.push(`- Test runner error: ${a.detail?.error || "unknown"}`);
      }
      if (q.explain) {
        lines.push("");
        lines.push(`> Notes: ${q.explain}`);
      }
      lines.push("");
    }

    lines.push(`---`);
    lines.push(`Generated by Tech Skill Assessor (offline HTML).`);
    return lines.join("\n");
  }

  async function copyToClipboard(text) {
    try {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        await navigator.clipboard.writeText(text);
        return true;
      }
    } catch (e) {}
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    try {
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch (e) {
      document.body.removeChild(ta);
      return false;
    }
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "text/markdown" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(url); document.body.removeChild(a); }, 0);
  }

  // ---------- events ----------
  function bindEvents() {
    byId("mode").value = state.mode;
    byId("length").value = state.length;

    byId("mode").addEventListener("change", (e) => { state.mode = e.target.value; persistState(); });
    byId("length").addEventListener("change", (e) => { state.length = e.target.value; persistState(); });

    byId("btnGenerate").addEventListener("click", () => {

      if (state.selectedTechs.size === 0) { alert("Select at least one technology."); return; }
      const qs = pickQuestions();

      // Build stable per-question option permutations so the correct answer position is randomized
      // but remains consistent while navigating (Prev/Next) and across reloads (localStorage).
      const variants = {}; // qid -> { order, answersShuffled }
      for (const q of qs) {
        if (q.type === "mcq" || q.type === "multi") {
          const order = shuffledOrder(q.options.length); // newIndex -> oldIndex
          const inv = invertOrder(order);                // oldIndex -> newIndex
          variants[q.id] = {
            order,
            answersShuffled: q.answer.map(oldIdx => inv[oldIdx]).sort((a,b)=>a-b),
          };
        }
      }

      state.quiz = { questions: qs.map(q => q.id), idx: 0, answers: {}, variants, timers: {}, activeQid: null };
      persistState();
      renderQuiz();
      byId("setupCard").style.display = "none";
    });

    byId("btnPrev").addEventListener("click", () => {
      const cur = state.quiz.questions[state.quiz.idx];
      stopTiming(cur);
      state.quiz.idx = clamp(state.quiz.idx - 1, 0, state.quiz.questions.length - 1);
      persistState();
      renderQuiz();
    });
    byId("btnNext").addEventListener("click", () => {
      const cur = state.quiz.questions[state.quiz.idx];
      stopTiming(cur);
      state.quiz.idx = clamp(state.quiz.idx + 1, 0, state.quiz.questions.length - 1);
      persistState();
      renderQuiz();
    });
    byId("btnCheck").addEventListener("click", () => { checkCurrent(); });

    byId("btnShowReport").addEventListener("click", () => {
      byId("reportCard").style.display = "";
      byId("resultsCard").style.display = "none";
      byId("mdOut").value = buildMarkdown();
    });

    byId("btnBackToResults").addEventListener("click", () => { renderResults(); });

    byId("btnCopyMd").addEventListener("click", async () => {
      const ok = await copyToClipboard(byId("mdOut").value);
      alert(ok ? "Copied." : "Copy failed (browser limitation).");
    });

    byId("btnDownloadMd").addEventListener("click", () => {
      downloadText("tech-skill-assessment.md", byId("mdOut").value);
    });

    byId("btnExport").addEventListener("click", async () => {
      if (!state.quiz) { alert("Generate an assessment first."); return; }
      const ok = await copyToClipboard(buildMarkdown());
      alert(ok ? "Report copied." : "Copy failed (browser limitation).");
    });

    byId("btnResetAll").addEventListener("click", () => {
      if (!confirm("Reset everything (including locked answers)?")) return;
      try { localStorage.removeItem(STORAGE_KEY); } catch (e) {}
      state.selectedTechs = new Set();
      state.mode = "mixed";
      state.length = "medium";
      state.quiz = null;
      stopTicker();
      renderAll();
    });
  }

  function renderAll() {
    renderTechGrid();
    byId("mode").value = state.mode;
    byId("length").value = state.length;

    if (state.quiz && state.quiz.questions?.length) {
      if (isAllChecked()) renderResults();
      else renderQuiz();
      byId("setupCard").style.display = "none";
    } else {
      stopTicker();
      byId("setupCard").style.display = "";
      byId("quizCard").style.display = "none";
      byId("resultsCard").style.display = "none";
      byId("reportCard").style.display = "none";
    }
  }

  // init
  async function init() {
    try {
      await loadBankAndTechs();
    } catch (e) {
      console.error(e);
      alert("Failed to load question bank/techs. Check server and JSON files.");
      return; // blocca l‚Äôapp se mancano i dati
    }

    restoreState();
    try { const tl = byId("timeThresholdLabel"); if (tl) tl.textContent = TIME_PENALTY_THRESHOLD_SEC + "s"; } catch(e) {}
    bindEvents();
    renderAll();
  }
  init();

</script>
</body>
</html>
